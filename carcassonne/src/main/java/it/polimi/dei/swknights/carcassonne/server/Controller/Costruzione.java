package it.polimi.dei.swknights.carcassonne.server.Controller;

import it.polimi.dei.swknights.carcassonne.server.Model.Segnalino;
import it.polimi.dei.swknights.carcassonne.server.Model.Tessere.Tessera;

import java.awt.Color;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;

/**
 * Class that implements the abstract idea of a human construction is used as
 * the base of the algorithm use to calculate victory points generated by
 * controlling constructions
 * 
 */

public abstract class Costruzione
{
	/**
	 * Default constructor Simply initialize a new construction whit at least
	 * one element
	 * 
	 * @param tessera
	 *            the first element of the construction
	 */

	public Costruzione(Tessera tessera)
	{
		this.listaSegnalini = new ArrayList<Segnalino>();
		this.elementi = new HashSet<Tessera>();

		this.elementi.add(tessera);
	}

	//TODO: ma che serve? ora è meglio, comunque...
	public abstract Costruzione getCopy(Tessera tessera);

	/**
	 * Method used to join two constructions
	 * 
	 * @param costruzione
	 *            The construction to be joined with
	 */

	public void joinCostruzioni(Costruzione costruzione)
	{
		this.elementi.addAll(costruzione.elementi);
		this.listaSegnalini.addAll(costruzione.listaSegnalini);
	}

	/**
	 * Method used to add a marker to this construction
	 * 
	 * @param segnalino
	 *            The marker to be added to this construction
	 */

	public void addSegnalino(Segnalino segnalino)
	{
		this.listaSegnalini.add(segnalino);
	}

	/**
	 * Method used to retrive the players that owns this construction
	 * 
	 * @return the list of the colors of the player controlling this
	 *         construction
	 */

	public List<Color> controllataDa()
	{
		final int nuovo = 1; // TODO di troppo?
		Map<Color, Integer> contatore = this.inizializzaContatore();
		for (Segnalino segnalino : this.listaSegnalini)
		{
			Color colore = segnalino.getColore();
			int contato = contatore.get(colore) + nuovo;
			contatore.put(colore, contato);
		}
		return this.getListaControllori(contatore);
	}

	/**
	 * Method that calculates the victory points generated from structure.
	 * 
	 * @param colore
	 *            the color of the considered player
	 * @return the point generated from this construction by the player
	 */

	public abstract int contaPuntiGiocatore(Color colore); // TODO ripensare!

	public int contaElementi()
	{
		return this.elementi.size();
	}

	private Map<Color, Integer> inizializzaContatore()
	{
		// TODO copia incolla è il male!
		Color colori[] = new Color[]
		{ Color.RED, Color.BLUE, Color.GREEN, Color.YELLOW, Color.BLACK };
		final int vuoto = 0; // TODO di troppo?
		Map<Color, Integer> contatore = new HashMap<Color, Integer>();
		for (Color colore : colori)
			contatore.put(colore, vuoto);
		return contatore;
	}

	// TODO da valutare
	private List<Color> getListaControllori(Map<Color, Integer> contatore)
	{
		int max = 1;
		List<Color> controllori = new ArrayList<Color>();
		for (Entry<Color, Integer> entryColore : contatore.entrySet())
		{
			int numeroSegnalini = entryColore.getValue();
			if (numeroSegnalini > max)
				max = numeroSegnalini;
		}
		for (Entry<Color, Integer> entryColore : contatore.entrySet())
		{
			if (entryColore.getValue() == max)
				controllori.add(entryColore.getKey());
		}
		return controllori;
	}


	/**
	 * returns true if the passed object is the same type of this building
	 * e.g.  city and city  or street and street
	 */
	/*
	@Override
	public boolean equals(Object obj)
	{
	  	if(! (obj instanceof Costruzione))
	  		return false;
	  	if ( obj instanceof CostruzioneCitta && this instanceof CostruzioneCitta ||
	  		obj instanceof CostruzioneStrada && this instanceof CostruzioneStrada )
	  		return true;
		return false;
	  		
	}
	*/

	protected Set<Tessera>	elementi;
	private List<Segnalino>	listaSegnalini;
}
