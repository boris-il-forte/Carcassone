package it.polimi.dei.swknights.carcassonne.server.Model.Tessere;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import it.polimi.dei.swknights.carcassonne.PuntoCardinale;
import it.polimi.dei.swknights.carcassonne.server.Controller.Confine;
import it.polimi.dei.swknights.carcassonne.server.Controller.Costruzione;

/**
 * This class is the abstract representation of the cards that can be placed on
 * the game table. Contains basic algorithms to control valid neighborhood, and
 * to retrieve the abstract constructions, to be used to calculate victory
 * points
 * 
 * @author edo & dave
 * 
 */

public abstract class Tessera
{
	Tessera(Lati lati, Link link)
	{
		this.lati = lati;
		this.link = link;
	}

	/**
	 * This method is used to make a clockwise rotation of the card
	 */
	public void ruota()
	{
		this.lati.ruota();
		this.link.ruota();
	}

	/**
	 * This method is used to retrieve victory points of the given element at
	 * the cardinal point
	 * 
	 * @param puntoCardinale
	 *            the required cardinal point
	 * @return the victory points generated by the selected element
	 */

	public int getPunteggio(PuntoCardinale puntoCardinale)
	{
		Elemento elemento = this.lati.getElementoInDirezione(puntoCardinale);
		return elemento.getPunteggio();
	}

	/**
	 * This method return whether the given card at the given position accepts
	 * the neighborhood of this card
	 * 
	 * @param tessera
	 *            the possible neighbor of the card that is being placed
	 * @param puntoCardinale
	 *            the position of the given card regard this card
	 * @return whether the card could be good neighbor
	 */

	public boolean buonVicino(Tessera tessera, PuntoCardinale puntoCardinale)
	{
		Elemento elementoMio = this.lati.getElementoInDirezione(puntoCardinale);
		Elemento elementoSuo = this.lati.getElementoInDirezione(puntoCardinale
				.opposto());

		return (elementoMio.stessoTipoElemento(elementoSuo));
	}

	public Map<Costruzione, List<PuntoCardinale>> getCostruzioni()
	{

		Map<Costruzione, List<PuntoCardinale>> mappaCostruzioniPunti = new HashMap<Costruzione, List<PuntoCardinale>>();

		Map<Costruzione, PuntoCardinale> mappaCostruzioni = lati
				.getMappaCostruzioniPrimitive(this);

		List<Costruzione> listCostruzione = new ArrayList<Costruzione>(
				mappaCostruzioni.keySet());
		Costruzione tempAggregato1 = null;
		Costruzione tempAggregato2 = null;
		boolean[] inglobati =
		{ false, false, false, false };

		int i = 0, j = 0;
		for (i = 0; i < listCostruzione.size() - 1; i++)
		{
			if(inglobati[i] == true) continue;
			List<PuntoCardinale> puntiCardinali= new ArrayList<PuntoCardinale>();
			tempAggregato1 = listCostruzione.get(i);

			for (j = i + 1; j < listCostruzione.size() - 1; j++)
			{
				puntiCardinali.add(mappaCostruzioni.get(tempAggregato1));
				if (isConnected(listCostruzione.get(i), listCostruzione.get(j),
						mappaCostruzioni))
				{
					inglobati[j] = true;
					puntiCardinali.add(mappaCostruzioni.get(tempAggregato2));
					tempAggregato2 = listCostruzione.get(j);
					tempAggregato1.joinCostruzioni(tempAggregato2);
				}
			}

			mappaCostruzioniPunti.put(tempAggregato1.getCopy(this), puntiCardinali);
		}

		return mappaCostruzioniPunti;
	}

	public Confine getConfine(PuntoCardinale puntoCardinale)
	{
		Elemento elemento = this.lati.getElementoInDirezione(puntoCardinale);
		return new Confine(this, elemento);
	}

	// volendo qua andrebbero i metodi astratti per la gestione del monastero...

	public abstract String toString();

	// volendo qua andrebbero i metodi astratti per la gestione del monastero...

	private boolean isConnected(Costruzione costruzione1,
			Costruzione costruzione2,
			Map<Costruzione, PuntoCardinale> mappaCostruzioni)
	{
		PuntoCardinale puntoCardinale1 = mappaCostruzioni.get(costruzione1);
		PuntoCardinale puntoCardinale2 = mappaCostruzioni.get(costruzione2);
		return this.link.areConnected(puntoCardinale1, puntoCardinale2);
	}

	protected final Lati lati;

	protected final Link link;

}
