package it.polimi.dei.swknights.carcassonne.server.Model.Tessere;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.Set;

import it.polimi.dei.swknights.carcassonne.PuntoCardinale;
import it.polimi.dei.swknights.carcassonne.server.Controller.Costruzione;

/**
 * This class is the abstract representation of the cards that can be placed on
 * the game table. Contains basic algorithms to control valid neighborhood, and
 * to retrieve the abstract constructions, to be used to calculate victory
 * points
 * 
 * @author edo & dave
 * 
 */
public abstract class Tessera {
	Tessera(Lati lati, Link link) {
		this.lati = lati;
		this.link = link;
	}

	/**
	 * This method is used to make a clockwise rotation of the card
	 */
	public void ruota() {
		this.lati.ruota();
		this.link.ruota();
	}

	/**
	 * This method is used to retrieve victory points of the given element at
	 * the cardinal point
	 * 
	 * @param puntoCardinale
	 *            the required cardinal point
	 * @return the victory points generated by the selected element
	 */

	public int getPunteggio(PuntoCardinale puntoCardinale) {
		Elemento elemento = this.lati.getElementoInDirezione(puntoCardinale);
		return elemento.getPunteggio();
	}

	/**
	 * This method return whether the given card at the given position accepts
	 * the neighborhood of this card
	 * 
	 * @param tessera
	 *            the possible neighbor of the card that is being placed
	 * @param puntoCardinale
	 *            the position of the given card regard this card
	 * @return whether the card could be good neighbor
	 */

	public boolean buonVicino(Tessera tessera, PuntoCardinale puntoCardinale) {
		Elemento elementoMio = this.lati.getElementoInDirezione(puntoCardinale);
		Elemento elementoSuo = this.lati
				.getElementoInDirezioneOpposta(puntoCardinale);

		return (elementoMio.stessoTipoElemento(elementoSuo));
	}

	public List<Costruzione> getCostruzioni() {
		
		Map<Costruzione, PuntoCardinale> mappaCostruzioni = lati
				.getListaCostruzioniPrimitive(this);
		
		List<Costruzione> listCostruzione = new ArrayList<Costruzione>();
		//travaso le chiavi in una lista (Ã¨ utile per il for che sia possibile get(i) )
		Set<Costruzione> CostruzioniKeys = mappaCostruzioni.keySet();
		for(Costruzione costruzione : CostruzioniKeys)
		{
			listCostruzione.add(costruzione);
		}
		

		List<Costruzione> listAggregati = new ArrayList<Costruzione>();
        Costruzione tempAggregato1=null;
        Costruzione tempAggregato2=null;
		boolean[] inglobati = {false, false, false, false};
		
        int i = 0, j = 0;
		for (i = 0; inglobati[i]==false && i < listCostruzione.size() - 1; i++)
		{
			tempAggregato1 = listCostruzione.get(i);
			
			for (j = i + 1; j < listCostruzione.size()-1; j++) 
			{
				if (connected(listCostruzione.get(i),
						listCostruzione.get(j), mappaCostruzioni))
				{
					inglobati[j]=true;
					
					tempAggregato2 = listCostruzione.get(j);
					tempAggregato1.joinCostruzioni(tempAggregato2);
				}
			}
			listAggregati.add( tempAggregato1.getCopy(this));
			tempAggregato1 = null;
		}

		return listCostruzione;
	}

	private boolean connected(Costruzione costruzione1, Costruzione costruzione2, Map<Costruzione, PuntoCardinale> mappaCostruzioni)
	{
		PuntoCardinale puntoCardinale1 = mappaCostruzioni.get(costruzione1);
		PuntoCardinale puntoCardinale2 = mappaCostruzioni.get(costruzione2);
		boolean linkNecessario=false;
		
		if (puntoCardinale1 == PuntoCardinale.nord && puntoCardinale2 == PuntoCardinale.est)
			linkNecessario = this.link.NE;

		if (puntoCardinale1 == PuntoCardinale.nord && puntoCardinale2 == PuntoCardinale.ovest)
			linkNecessario = this.link.NO;

		if (puntoCardinale1 == PuntoCardinale.nord && puntoCardinale2 == PuntoCardinale.sud)
			linkNecessario = this.link.SN;
		
		

		if (puntoCardinale1 == PuntoCardinale.sud && puntoCardinale2 == PuntoCardinale.est)
			linkNecessario = this.link.SE;

		if (puntoCardinale1 == PuntoCardinale.sud && puntoCardinale2 == PuntoCardinale.ovest)
			linkNecessario = this.link.SO;
		

		if (puntoCardinale1 == PuntoCardinale.est && puntoCardinale2 == PuntoCardinale.ovest)
			linkNecessario = this.link.OE;
		
		return linkNecessario;

		
	}

	
	public Confine getConfine()
	{
		//TODO: da fare!
	}
	
	// volendo qua andrebbero i metodi astratti per la gestione del monastero...

	public abstract String toString();

	protected final Lati lati;
	protected final Link link;

}
