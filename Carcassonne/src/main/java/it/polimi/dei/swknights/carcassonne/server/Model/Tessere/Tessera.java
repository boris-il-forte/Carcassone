package it.polimi.dei.swknights.carcassonne.server.Model.Tessere;

import it.polimi.dei.swknights.carcassonne.PuntoCardinale;

/**
 * This class is the abstract representation of the cards that can be placed on
 * the game table. Contains basic algorithms to control valid neighborhood, and
 * to retrieve the abstract constructions, to be used to calculate victory
 * points
 * 
 * @author edo & dave
 * 
 */
public abstract class Tessera
{
	Tessera(Lati lati, Link link)
	{
		this.lati = lati;
		this.link = link;
	}

	/**
	 * This method is used to make a clockwise rotation of the card
	 */
	public void ruota()
	{
		this.lati.ruota();
		this.link.ruota();
	}

	/**
	 * This method is used to retrieve victory points of the given element at the
	 * cardinal point
	 * 
	 * @param puntoCardinale
	 *            the required cardinal point
	 * @return the victory points generated by the selected element
	 */

	public int getPunteggio(PuntoCardinale puntoCardinale)
	{
		Elemento elemento = this.lati.getElementoInDirezione(puntoCardinale);
		return elemento.getPunteggio();
	}

	/**
	 * This method return whether the given card at the given position accepts the
	 * neighborhood of this card
	 * 
	 * @param tessera
	 *            the possible neighbor of the card that is being placed
	 * @param puntoCardinale
	 *            the position of the given card regard this card
	 * @return whether the card could be good neighbor
	 */

	public boolean buonVicino(Tessera tessera, PuntoCardinale puntoCardinale)
	{
		Elemento elementoMio = this.lati.getElementoInDirezione(puntoCardinale);
		Elemento elementoSuo = this.lati
				.getElementoInDirezioneOpposta(puntoCardinale);

		return (elementoMio.equals(elementoSuo)); // TODO: bene equals o
													// sonoSimili?

	}

	// volendo qua andrebbero i metodi astratti per la gestione del monastero...

	public abstract String toString();

	protected final Lati lati;
	protected final Link link;

}
