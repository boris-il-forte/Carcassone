package it.polimi.dei.swknights.carcassonne.server.Model.Tessere;

import java.util.ArrayList;
import java.util.List;

import it.polimi.dei.swknights.carcassonne.PuntoCardinale;
import it.polimi.dei.swknights.carcassonne.server.Controller.Costruzione;

/**
 * This class is the abstract representation of the cards that can be placed on
 * the game table. Contains basic algorithms to control valid neighborhood, and
 * to retrieve the abstract constructions, to be used to calculate victory
 * points
 * 
 * @author edo & dave
 * 
 */
public abstract class Tessera {
	Tessera(Lati lati, Link link) {
		this.lati = lati;
		this.link = link;
	}

	/**
	 * This method is used to make a clockwise rotation of the card
	 */
	public void ruota() {
		this.lati.ruota();
		this.link.ruota();
	}

	/**
	 * This method is used to retrieve victory points of the given element at
	 * the cardinal point
	 * 
	 * @param puntoCardinale
	 *            the required cardinal point
	 * @return the victory points generated by the selected element
	 */

	public int getPunteggio(PuntoCardinale puntoCardinale) {
		Elemento elemento = this.lati.getElementoInDirezione(puntoCardinale);
		return elemento.getPunteggio();
	}

	/**
	 * This method return whether the given card at the given position accepts
	 * the neighborhood of this card
	 * 
	 * @param tessera
	 *            the possible neighbor of the card that is being placed
	 * @param puntoCardinale
	 *            the position of the given card regard this card
	 * @return whether the card could be good neighbor
	 */

	public boolean buonVicino(Tessera tessera, PuntoCardinale puntoCardinale) {
		Elemento elementoMio = this.lati.getElementoInDirezione(puntoCardinale);
		Elemento elementoSuo = this.lati
				.getElementoInDirezioneOpposta(puntoCardinale);

		return (elementoMio.stessoTipoElemento(elementoSuo));
	}

	public List<Costruzione> getCostruzioni() {
		List<Costruzione> listCostruzione = lati
				.getListaCostruzioniPrimitive(this);

		List<Costruzione> listAggregati = new ArrayList<Costruzione>();
        Costruzione tempAggregato1=null;
        Costruzione tempAggregato2=null;
		boolean[] inglobati = {false, false, false, false};
		
        int i = 0, j = 0;
		for (i = 0; inglobati[i]==false && i < listCostruzione.size() - 1; i++)
		{
			tempAggregato1 = listCostruzione.get(i);
			
			for (j = i + 1; j < listCostruzione.size()-1; j++) 
			{
				if (connected(listCostruzione.get(i),
						listCostruzione.get(j)))
				{
					inglobati[j]=true;
					
					tempAggregato2 = listCostruzione.get(j);
					tempAggregato1.joinCostruzioni(tempAggregato2);
				}
			}
			listAggregati.add( tempAggregato1.getCopy(this));
			tempAggregato1 = null;
		}

		return listAggregati;
	}

	private boolean connected(Costruzione c1, Costruzione c2) {
		// TODO: fare
		return true;
	}

	// volendo qua andrebbero i metodi astratti per la gestione del monastero...

	public abstract String toString();

	protected final Lati lati;
	protected final Link link;

}
